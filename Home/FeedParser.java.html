<html>
<head>
<title>FeedParser.java</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080; font-style: italic;}
.s1 { color: #000000;}
.s2 { color: #000080; font-weight: bold;}
.s3 { color: #808080; font-style: italic;}
.s4 { color: #0000ff;}
.s5 { color: #808080; font-weight: bold; font-style: italic;}
.s6 { color: #658aba; font-weight: bold;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
FeedParser.java</font>
</center></td></tr></table>
<pre><span class="s0">/* 
 * Copyright 2013 The Android Open Source Project 
 * 
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); 
 * you may not use this file except in compliance with the License. 
 * You may obtain a copy of the License at 
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0 
 * 
 * Unless required by applicable law or agreed to in writing, software 
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
 * See the License for the specific language governing permissions and 
 * limitations under the License. 
 */</span>

<span class="s2">package </span>com.example.android.basicsyncadapter.net;

<span class="s2">import </span>android.text.format.Time;
<span class="s2">import </span>android.util.Xml;

<span class="s2">import </span>org.xmlpull.v1.XmlPullParser;
<span class="s2">import </span>org.xmlpull.v1.XmlPullParserException;

<span class="s2">import </span>java.io.IOException;
<span class="s2">import </span>java.io.InputStream;
<span class="s2">import </span>java.text.ParseException;
<span class="s2">import </span>java.util.ArrayList;
<span class="s2">import </span>java.util.List;

<span class="s0">/**</span>
 * This class parses generic Atom feeds.
 *
 * <span class="s3">&lt;p&gt;</span><span class="s0">Given an InputStream representation of a feed, it returns a List of entries,</span>
 * where each list element represents a single entry (post) in the XML feed.
 *
 * <span class="s3">&lt;p&gt;</span><span class="s0">An example of an Atom feed can be found at:</span>
 * http://en.wikipedia.org/w/index.php?title=Atom_(standard)&amp;oldid=560239173#Example_of_an_Atom_1.0_feed
 */
<span class="s2">public class </span>FeedParser {

    <span class="s0">// Constants indicting XML element names that we're interested in</span>
    <span class="s2">private static final int </span>TAG_ID = <span class="s4">1</span>;
    <span class="s2">private static final int </span>TAG_TITLE = <span class="s4">2</span>;
    <span class="s2">private static final int </span>TAG_PUBLISHED = <span class="s4">3</span>;
    <span class="s2">private static final int </span>TAG_LINK = <span class="s4">4</span>;

    <span class="s0">// We don't use XML namespaces</span>
    <span class="s2">private static final </span>String ns = <span class="s2">null</span>;

    <span class="s0">/** Parse an Atom feed, returning a collection of Entry objects.</span>
     *
     * <span class="s5">@param </span><span class="s0">in Atom feed, as a stream.</span>
     * <span class="s5">@return </span><span class="s0">List of {</span><span class="s5">@link </span><span class="s0">com.example.android.basicsyncadapter.net.FeedParser.Entry} objects.</span>
     * <span class="s5">@throws </span><span class="s0">org.xmlpull.v1.XmlPullParserException on error parsing feed.</span>
     * <span class="s5">@throws </span><span class="s0">java.io.IOException on I/O error.</span>
     */
    <span class="s2">public </span>List&lt;Entry&gt; parse(InputStream in)
            <span class="s2">throws </span>XmlPullParserException, IOException, ParseException {
        <span class="s2">try </span>{
            XmlPullParser parser = Xml.newPullParser();
            parser.setFeature(XmlPullParser.FEATURE_PROCESS_NAMESPACES, <span class="s2">false</span>);
            parser.setInput(in, <span class="s2">null</span>);
            parser.nextTag();
            <span class="s2">return </span>readFeed(parser);
        } <span class="s2">finally </span>{
            in.close();
        }
    }

    <span class="s0">/**</span>
     * Decode a feed attached to an XmlPullParser.
     *
     * <span class="s5">@param </span><span class="s0">parser Incoming XMl</span>
     * <span class="s5">@return </span><span class="s0">List of {</span><span class="s5">@link </span><span class="s0">com.example.android.basicsyncadapter.net.FeedParser.Entry} objects.</span>
     * <span class="s5">@throws </span><span class="s0">org.xmlpull.v1.XmlPullParserException on error parsing feed.</span>
     * <span class="s5">@throws </span><span class="s0">java.io.IOException on I/O error.</span>
     */
    <span class="s2">private </span>List&lt;Entry&gt; readFeed(XmlPullParser parser)
            <span class="s2">throws </span>XmlPullParserException, IOException, ParseException {
        List&lt;Entry&gt; entries = <span class="s2">new </span>ArrayList&lt;Entry&gt;();

        <span class="s0">// Search for &lt;feed&gt; tags. These wrap the beginning/end of an Atom document.</span>
        //
        // Example:
        // &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
        // &lt;feed xmlns=&quot;http://www.w3.org/2005/Atom&quot;&gt;
        // ...
        // &lt;/feed&gt;
        parser.require(XmlPullParser.START_TAG, ns, <span class="s6">&quot;feed&quot;</span>);
        <span class="s2">while </span>(parser.next() != XmlPullParser.END_TAG) {
            <span class="s2">if </span>(parser.getEventType() != XmlPullParser.START_TAG) {
                <span class="s2">continue</span>;
            }
            String name = parser.getName();
            <span class="s0">// Starts by looking for the &lt;entry&gt; tag. This tag repeates inside of &lt;feed&gt; for each</span>
            // article in the feed.
            //
            // Example:
            // &lt;entry&gt;
            //   &lt;title&gt;Article title&lt;/title&gt;
            //   &lt;link rel=&quot;alternate&quot; type=&quot;text/html&quot; href=&quot;http://example.com/article/1234&quot;/&gt;
            //   &lt;link rel=&quot;edit&quot; href=&quot;http://example.com/admin/article/1234&quot;/&gt;
            //   &lt;id&gt;urn:uuid:218AC159-7F68-4CC6-873F-22AE6017390D&lt;/id&gt;
            //   &lt;published&gt;2003-06-27T12:00:00Z&lt;/published&gt;
            //   &lt;updated&gt;2003-06-28T12:00:00Z&lt;/updated&gt;
            //   &lt;summary&gt;Article summary goes here.&lt;/summary&gt;
            //   &lt;author&gt;
            //     &lt;name&gt;Rick Deckard&lt;/name&gt;
            //     &lt;email&gt;deckard@example.com&lt;/email&gt;
            //   &lt;/author&gt;
            // &lt;/entry&gt;
            <span class="s2">if </span>(name.equals(<span class="s6">&quot;entry&quot;</span>)) {
                entries.add(readEntry(parser));
            } <span class="s2">else </span>{
                skip(parser);
            }
        }
        <span class="s2">return </span>entries;
    }

    <span class="s0">/**</span>
     * Parses the contents of an entry. If it encounters a title, summary, or link tag, hands them
     * off to their respective &quot;read&quot; methods for processing. Otherwise, skips the tag.
     */
    <span class="s2">private </span>Entry readEntry(XmlPullParser parser)
            <span class="s2">throws </span>XmlPullParserException, IOException, ParseException {
        parser.require(XmlPullParser.START_TAG, ns, <span class="s6">&quot;entry&quot;</span>);
        String id = <span class="s2">null</span>;
        String title = <span class="s2">null</span>;
        String link = <span class="s2">null</span>;
        <span class="s2">long </span>publishedOn = <span class="s4">0</span>;

        <span class="s2">while </span>(parser.next() != XmlPullParser.END_TAG) {
            <span class="s2">if </span>(parser.getEventType() != XmlPullParser.START_TAG) {
                <span class="s2">continue</span>;
            }
            String name = parser.getName();
            <span class="s2">if </span>(name.equals(<span class="s6">&quot;id&quot;</span>)){
                <span class="s0">// Example: &lt;id&gt;urn:uuid:218AC159-7F68-4CC6-873F-22AE6017390D&lt;/id&gt;</span>
                id = readTag(parser, TAG_ID);
            } <span class="s2">else if </span>(name.equals(<span class="s6">&quot;title&quot;</span>)) {
                <span class="s0">// Example: &lt;title&gt;Article title&lt;/title&gt;</span>
                title = readTag(parser, TAG_TITLE);
            } <span class="s2">else if </span>(name.equals(<span class="s6">&quot;link&quot;</span>)) {
                <span class="s0">// Example: &lt;link rel=&quot;alternate&quot; type=&quot;text/html&quot; href=&quot;http://example.com/article/1234&quot;/&gt;</span>
                //
                // Multiple link types can be included. readAlternateLink() will only return
                // non-null when reading an &quot;alternate&quot;-type link. Ignore other responses.
                String tempLink = readTag(parser, TAG_LINK);
                <span class="s2">if </span>(tempLink != <span class="s2">null</span>) {
                    link = tempLink;
                }
            } <span class="s2">else if </span>(name.equals(<span class="s6">&quot;published&quot;</span>)) {
                <span class="s0">// Example: &lt;published&gt;2003-06-27T12:00:00Z&lt;/published&gt;</span>
                Time t = <span class="s2">new </span>Time();
                t.parse3339(readTag(parser, TAG_PUBLISHED));
                publishedOn = t.toMillis(<span class="s2">false</span>);
            } <span class="s2">else </span>{
                skip(parser);
            }
        }
        <span class="s2">return new </span>Entry(id, title, link, publishedOn);
    }

    <span class="s0">/**</span>
     * Process an incoming tag and read the selected value from it.
     */
    <span class="s2">private </span>String readTag(XmlPullParser parser, <span class="s2">int </span>tagType)
            <span class="s2">throws </span>IOException, XmlPullParserException {
        String tag = <span class="s2">null</span>;
        String endTag = <span class="s2">null</span>;

        <span class="s2">switch </span>(tagType) {
            <span class="s2">case </span>TAG_ID:
                <span class="s2">return </span>readBasicTag(parser, <span class="s6">&quot;id&quot;</span>);
            <span class="s2">case </span>TAG_TITLE:
                <span class="s2">return </span>readBasicTag(parser, <span class="s6">&quot;title&quot;</span>);
            <span class="s2">case </span>TAG_PUBLISHED:
                <span class="s2">return </span>readBasicTag(parser, <span class="s6">&quot;published&quot;</span>);
            <span class="s2">case </span>TAG_LINK:
                <span class="s2">return </span>readAlternateLink(parser);
            <span class="s2">default</span>:
                <span class="s2">throw new </span>IllegalArgumentException(<span class="s6">&quot;Unknown tag type: &quot; </span>+ tagType);
        }
    }

    <span class="s0">/**</span>
     * Reads the body of a basic XML tag, which is guaranteed not to contain any nested elements.
     *
     * <span class="s3">&lt;p&gt;</span><span class="s0">You probably want to call readTag().</span>
     *
     * <span class="s5">@param </span><span class="s0">parser Current parser object</span>
     * <span class="s5">@param </span><span class="s0">tag XML element tag name to parse</span>
     * <span class="s5">@return </span><span class="s0">Body of the specified tag</span>
     * <span class="s5">@throws </span><span class="s0">java.io.IOException</span>
     * <span class="s5">@throws </span><span class="s0">org.xmlpull.v1.XmlPullParserException</span>
     */
    <span class="s2">private </span>String readBasicTag(XmlPullParser parser, String tag)
            <span class="s2">throws </span>IOException, XmlPullParserException {
        parser.require(XmlPullParser.START_TAG, ns, tag);
        String result = readText(parser);
        parser.require(XmlPullParser.END_TAG, ns, tag);
        <span class="s2">return </span>result;
    }

    <span class="s0">/**</span>
     * Processes link tags in the feed.
     */
    <span class="s2">private </span>String readAlternateLink(XmlPullParser parser)
            <span class="s2">throws </span>IOException, XmlPullParserException {
        String link = <span class="s2">null</span>;
        parser.require(XmlPullParser.START_TAG, ns, <span class="s6">&quot;link&quot;</span>);
        String tag = parser.getName();
        String relType = parser.getAttributeValue(<span class="s2">null</span>, <span class="s6">&quot;rel&quot;</span>);
        <span class="s2">if </span>(relType.equals(<span class="s6">&quot;alternate&quot;</span>)) {
            link = parser.getAttributeValue(<span class="s2">null</span>, <span class="s6">&quot;href&quot;</span>);
        }
        <span class="s2">while </span>(<span class="s2">true</span>) {
            <span class="s2">if </span>(parser.nextTag() == XmlPullParser.END_TAG) <span class="s2">break</span>;
            <span class="s0">// Intentionally break; consumes any remaining sub-tags.</span>
        }
        <span class="s2">return </span>link;
    }

    <span class="s0">/**</span>
     * For the tags title and summary, extracts their text values.
     */
    <span class="s2">private </span>String readText(XmlPullParser parser) <span class="s2">throws </span>IOException, XmlPullParserException {
        String result = <span class="s2">null</span>;
        <span class="s2">if </span>(parser.next() == XmlPullParser.TEXT) {
            result = parser.getText();
            parser.nextTag();
        }
        <span class="s2">return </span>result;
    }

    <span class="s0">/**</span>
     * Skips tags the parser isn't interested in. Uses depth to handle nested tags. i.e.,
     * if the next tag after a START_TAG isn't a matching END_TAG, it keeps going until it
     * finds the matching END_TAG (as indicated by the value of &quot;depth&quot; being 0).
     */
    <span class="s2">private void </span>skip(XmlPullParser parser) <span class="s2">throws </span>XmlPullParserException, IOException {
        <span class="s2">if </span>(parser.getEventType() != XmlPullParser.START_TAG) {
            <span class="s2">throw new </span>IllegalStateException();
        }
        <span class="s2">int </span>depth = <span class="s4">1</span>;
        <span class="s2">while </span>(depth != <span class="s4">0</span>) {
            <span class="s2">switch </span>(parser.next()) {
                <span class="s2">case </span>XmlPullParser.END_TAG:
                    depth--;
                    <span class="s2">break</span>;
                <span class="s2">case </span>XmlPullParser.START_TAG:
                    depth++;
                    <span class="s2">break</span>;
            }
        }
    }

    <span class="s0">/**</span>
     * This class represents a single entry (post) in the XML feed.
     *
     * <span class="s3">&lt;p&gt;</span><span class="s0">It includes the data members &quot;title,&quot; &quot;link,&quot; and &quot;summary.&quot;</span>
     */
    <span class="s2">public static class </span>Entry {
        <span class="s2">public final </span>String id;
        <span class="s2">public final </span>String title;
        <span class="s2">public final </span>String link;
        <span class="s2">public final long </span>published;

        Entry(String id, String title, String link, <span class="s2">long </span>published) {
            <span class="s2">this</span>.id = id;
            <span class="s2">this</span>.title = title;
            <span class="s2">this</span>.link = link;
            <span class="s2">this</span>.published = published;
        }
    }
}
</pre>
</body>
</html>